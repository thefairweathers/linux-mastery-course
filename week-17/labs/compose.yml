# =============================================================================
# Docker Compose — Three-Tier Application Stack
# =============================================================================
# This compose file orchestrates the three-tier application:
#   - nginx reverse proxy (frontend)
#   - Flask Task API (middleware)
#   - PostgreSQL database (backend)
#
# This is the same application you built manually in Weeks 12-13 and
# containerized by hand in Week 16, now orchestrated with Compose.
#
# Usage:
#   docker compose up -d --build    # Build and start all services
#   docker compose ps               # Check service status and health
#   docker compose logs -f          # Follow all logs
#   docker compose down             # Stop and remove containers
#   docker compose down -v          # Stop, remove containers AND volumes (data loss!)
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # PostgreSQL Database
  # ---------------------------------------------------------------------------
  db:
    image: postgres:16-alpine
    # TODO 1: Add environment variables for POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD
    # HINT: Use env_file to load from .env, or set them directly with environment:
    env_file:
      - .env

    # TODO 2: Add a named volume for data persistence
    # HINT: Mount pgdata:/var/lib/postgresql/data
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro

    # TODO 3: Add a health check using pg_isready
    # HINT: pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

    # TODO 4: Add restart policy and logging limits
    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

    networks:
      - backend

  # ---------------------------------------------------------------------------
  # Flask Task API
  # ---------------------------------------------------------------------------
  api:
    # TODO 5: Build from the Dockerfile.api in the current directory
    # HINT: Use build: with context and dockerfile
    build:
      context: .
      dockerfile: Dockerfile.api

    # TODO 6: Set database connection environment variables
    # HINT: DB_HOST should be "db" (the service name above — Docker DNS resolves it)
    environment:
      - DB_HOST=db
      - DB_PORT=5432
    env_file:
      - .env

    # TODO 7: Add depends_on with health check condition
    # HINT: The API should wait for the database to be healthy
    depends_on:
      db:
        condition: service_healthy

    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

    networks:
      - frontend
      - backend

  # ---------------------------------------------------------------------------
  # nginx Reverse Proxy
  # ---------------------------------------------------------------------------
  web:
    # TODO 8: Build from Dockerfile.nginx
    build:
      context: .
      dockerfile: Dockerfile.nginx

    # TODO 9: Map port 80 on the host to port 80 in the container
    ports:
      - "80:80"

    depends_on:
      api:
        condition: service_healthy

    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

    networks:
      - frontend

# =============================================================================
# Networks
# =============================================================================
# TODO 10: Define two custom networks
# The frontend network connects nginx <-> API
# The backend network connects API <-> database
# Note: nginx is NOT on the backend network (can't reach the database directly)
networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge

# =============================================================================
# Volumes
# =============================================================================
volumes:
  pgdata:
    driver: local
